//#include"Series.cpp"
#include"Includes.h"
#include"DataFrame.h"



int main(){
    std::cout << "This is framework for DataFrames based on C++. The main difference from, for example, Pandas is that using this\n";
    std:: cout <<"library allow users to contain only any kind of int, double, float, std::string and bool types. Here are the examples to see how it works.\n";
    std:: cout << "The components of the DataFrame are Serieses. Each Series consist of only one type elements(for ex. int). \n";
    std::cout << "To initialize Series there are 2 ways: \n";
    std::cout << "1) Series<int> series1" << '\n'; 
    std::cout << "2) Series<int> series2('B', {1, 2, 10, 5, 4, 3})" << '\n';
    std::cout << "The 2nd initialization get string name of the series and vector of the claimed type\n";
    std::cout << "To print series use method print()." << '\n' << '\n';
    Series<int> series1;
    Series<int> series2("B", {1, 2, 10, 5, 4, 3});
    series1.print();
    series2.print();
    std::cout << '\n';
    std::cout<<"As we can see series1 doesn't have name and elements in it. \n";
    std::cout << "To set the name use the method SetName(name(string)). \n";
    std::cout << "To add elements use the method AddElement(element). Take into account that element must be the same type as the series. \n";
    std::cout << '\n';
    series1.SetName("A");
    series1.AddElement(3);
    series1.AddElement(4);
    series1.AddElement(8);
    series1.print();
    std::cout << '\n';
    std::cout << "Also it is possible to to add several elements to series using the method AddSeries(std::vector<T>). \n";
    std::cout << '\n';
    series1.AddSeries({7, 3, 3});
    series1.print();
    std::cout << '\n';
    std::cout << "To get mean, max, min of the numeric series use methods Mean(), Max(), Min(). \n";
    std::cout << '\n';
    std::cout << "Mean of series1: " << series1.Mean() << '\n';
    std::cout << "Max of series1: " << series1.Max() << '\n';
    std::cout << "Min of series1: " << series1.Min() << '\n';
    std::cout << '\n';
    std::cout << "Also it is possible to count the numbrt of certain element in the series using the method Count(T element). \n";
    std::cout << '\n';
    std::cout << "Number of 3 in A: " << series1.Count(3) << '\n';
    std::cout << '\n';
    std::cout << "To get unique elements of the series use the method UniqueElements() which returns std::vector<T>. \n";
    std:: cout << '\n';
    // std::cout << "Unique elements of series1: " << series1.UniqueElements() << '\n';
    // std::cout << "Unique elements of series2: " << series2.UniqueElements() << '\n';
    std::cout << "It's possible to use math's operations for the same type of serieses. \n";
    std::cout << "Mention that if you want to get double from the division of 2 int serieses you should transform both to double type using the method ToDouble(). \n";
    std::cout << '\n';
    Series<int> add_ser = series1 + series2;
    add_ser.SetName("A + B");
    std::cout << "A + B: "; add_ser.print();
    Series<int> sub_ser = series1 - series2;
    sub_ser.SetName("A - B");
    std::cout << "A - B: "; sub_ser.print();  
    Series<int> mul_ser = series1 * series2;
    mul_ser.SetName("A * B");
    std::cout << "A * B: "; mul_ser.print(); 
    Series<double> div_ser = series1.ToDouble() / series2.ToDouble();
    div_ser.SetName("A / B");
    std::cout << "A / B: "; div_ser.print();
    std::cout << '\n';
    std::cout << "Also it is possible to use math's to each element of the series. For example: \n";
    std::cout << '\n';
    Series<int> twice_ser1 = series1 * 2;
    twice_ser1.SetName("2 * A");
    twice_ser1.print();
    std::cout << '\n';
    std::cout << "To initialize DataFrame the only way is: \n DataFrame df; \n";
    std::cout << "To add columns to your DataFrame use the method AddColumn<T>(string name(optional), Series<T> series). \n";
    std::cout << "To count number of columns or rows use the methods CountColumns(), CountRows(). \n";
    std::cout << "To print the dataframe use the methods Head(int n(number of rows you want to print)) or Tail(int n(number of rows you want to print)). \n ";
    std::cout << '\n';
    DataFrame df;
    df.AddColumn<int>(series1);
    df.AddColumn<int>(series2);
    df.AddColumn<int>(add_ser);
    df.AddColumn<int>(sub_ser);
    df.AddColumn<int>(mul_ser);
    df.AddColumn<double>(div_ser);
    df.AddColumn<int>(twice_ser1);
    df.Head(df.CountRows());
    std::cout << df.CountRows() << " rows x "<< df.CountColumns() << " columns " << '\n';
    std::cout << '\n';
    std::cout << "To get the type of the column use the method GetTypeOfColumn(int index or string name_of_column) which returns string. \n";
    std::cout << "To get the column use the method GetColumn<T>(int index_of_column or string name_of_column) \n";
    std::cout << '\n';
    std::cout << "Type of the column A / B " << df.GetTypeOfColumn("A / B") << '\n';
    df.GetColumn<double>(5).print();
    std::cout << '\n';
    std::cout << "To drop the column use the method Drop(int index_of_column or string name_of_column). Mention that it changes the the original dataframe. \n";
    std::cout << '\n';
    std::cout << "After Drop(2 * A): \n";
    df.Drop("2 * A");
    df.Head(100);
    std::cout << '\n';
    std::cout << "It is possible to get the element from dataframe using the method Locate<T>(int row_index, int column_index). \n";
    std::cout << '\n';
    std::cout << "Locate(1, 2): " << df.Locate<int>(1, 2) << '\n';
    std::cout << '\n';
    std::cout << "Also method Locate(int row_begin, row_end, column_begin, column_end) return the part of the dataframe. \n";
    std::cout << '\n' << "Locate(0, 3, 1, 5): \n";
    df.Locate(0, 3, 1, 5).Head(10);
    std::cout << '\n';
    std::cout << "It is possible to sort the dataframe using the method SortBy<T>(string name_of_column, bool true if ascending else false). \n";
    std::cout << "Mention that SortBy returns new DataFrame and do not change the original one. \n";
    std::cout << "For example we will sort by column A with ascend. \n";
    std::cout << '\n';
    df.SortBy<int>("A", true).Head(100);
    std::cout << '\n';
    std::cout << "Or sort by A + B with descend. \n";
    std::cout << '\n';
    df.SortBy<int>("B", false).Head(100);
    std::cout << '\n';
    std::cout << "Method GroupBy<T>(string name_of_column, string name_of_function). Allowed functions: Count, Max, Min, Sum, Mean. \n";
    std::cout << '\n';
    std::cout << "GroupBy<int>(A, Count):" << '\n';
    df.GroupBy<int>("A", "Count").Head(100);
    std::cout << "GroupBy<int>(A, Sum):" << '\n';
    df.GroupBy<int>("A", "Sum").Head(100);
    std::cout << "GroupBy<int>(A, Mean):" << '\n';
    df.GroupBy<int>("A", "Mean").Head(100);
    std::cout << '\n';
    std::cout << "To select rows which are equal to something it is possible to use the method Select<T>(string name_of_column, T target_element, func).";
    std::cout << "This method returns new DataFrame. \n";
    std::cout << '\n';
    std::cout << "Add string series to our DataFrame. \n";
    Series<string> str("String", {"AA", "B", "SB", "AA", "AA", "B"});
    df.AddColumn<string>(str);
    df.Head(100);
    std::cout << "Now we will select only rows which contain AA in String column, using Select<string>(String, AA, func(look at the code)): \n";
    //df.Select<string>("String", "B", [](string tar_element, string cur_element){if (tar_element == cur_element) return true; else false;}).Head(100);
    df.Select<string>("String", "AA", [](string tar_element, string cur_element){if (tar_element == cur_element) return true; else false;}).Head(100);
    std::cout << '\n';
    std::cout << "Usually to work with dataframe, firstly, we have to get it from the .csv file. To do it use the method ReadCSV(string name_of_csvfile). \n";
    std::cout <<"ReadCSV() automatically transform numeric types to int64_t or double. \n";
    std::cout << '\n';
    std::cout << "We will use popular database of Titanic to demonstrate. \n";
    DataFrame titanic;
    titanic.ReadCSV("new_titanic.csv");
    titanic.Drop(0);
    titanic.Head(5);
    std::cout << titanic.CountRows() << " rows x "<< titanic.CountColumns() << " columns " << '\n';
    std::cout << '\n';
    std::cout << "Lets find out how many people survived using titanic.GetColumn<i64>(Survived).Count(1). \n";
    std::cout << "Number of survived: " << titanic.GetColumn<i64>("Survived").Count(1) << '\n';
    std::cout << '\n';
    std::cout << "Now lets find out how many survived from each Pclass (look into a code because there are several steps to build such dataframe): \n";
    DataFrame surv;
    surv = titanic.GroupBy<i64>("Pclass", "Sum");
    surv = surv.Locate(0, surv.CountRows(), 0, 2);
    surv.AddColumn<i64>("Out of", titanic.GroupBy<i64>("Pclass", "Count").GetColumn<i64>(1));
    surv.AddColumn<double>("%", (surv.GetColumn<i64>("Survived").ToDouble() / surv.GetColumn<i64>("Out of").ToDouble()) * 100);
    surv = surv.SortBy<double>("%", false);
    surv.Head(12);
    std::cout << '\n';
    std::cout << "To save our dataframe in csv we use the method WriteCSV(string name_of_csvfile). \n";
    std::cout << "Lets save in Survived.csv \n";
    surv.WriteCSV("Survived.csv");
    // surv.ReadCSV("Survived.csv");
    // surv.Head(100);
    std::cout << '\n';
    std::cout << "Lets find out out the average age of men who managed to survive: \n";
    std::cout << '\n';
    DataFrame men;
    men = titanic.Select<string>("Sex", "male", [](string tar_element, string cur_element){if (tar_element == cur_element) {return true;} else {false;}});
    men = men.Select<i64>("Survived", 1, [](i64 tar_element, i64 cur_element){if (tar_element == cur_element) { /*std::cout <<"true "<< cur_element << '\n';*/ return true;} else {/*std::cout <<"false "<< cur_element << '\n';*/ false;}});
    //men.Head(100);
    men.Head(10);
    std::cout << men.GetColumn<double>("Age").Count(0) << '\n';
    std::cout << "Average age: " << men.GetColumn<double>("Age").Mean() << '\n';
    return 0;
}
